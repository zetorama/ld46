go.property('distance_per_step', 16)
go.property('speed', 20)
go.property('should_walk_on_start', true)
go.property('max_attempts', 3)

local log = require 'utils.log'

local TARGET_THRESHOLD = 16

local function reset(self)
	self.facing = 'front'
	self.anim = nil
	self.dir = vmath.vector3()
	self.correction = vmath.vector3()
	self.target = nil
	self.attempts = 0
end

local function animate_character(self)
	local is_moving = vmath.length(self.dir) > 0

	if is_moving then
		if self.dir.y > 0 then
			self.facing = 'back'
		elseif self.dir.x == 0 then
			self.facing = 'front'
		elseif self.dir.x < 0 then
			self.facing = 'left'
		else
			self.facing = 'right'
		end
	end

	local prefix = 'robot'
	local state = is_moving and 'walk' or 'idle'
	local tool = 'empty'
	local anim = hash(prefix .. '-' .. state .. '-' .. tool .. '-' .. self.facing)

	if self.anim ~= anim then
		self.anim = anim
		msg.post('#sprite', 'play_animation', {id = self.anim})
	end
end


local function stop(self)
	-- TODO: give feedback, that robot cannot move anymore
	print('ROBOT: no more walkie')
	go.cancel_animations('.', 'position')
	particlefx.stop('marker#particles')

	self.target = nil
	self.attempts = 0
	self.dir = vmath.vector3()
	animate_character(self)
end

local function goto_target(self)
	if not self.target then
		stop(self)
		return
	end

	go.set_position(self.target, 'marker')
	particlefx.play('marker#particles')

	local pos = go.get_position()
	local dir = self.target - pos
	local distance = vmath.length(dir)

	if (distance <= TARGET_THRESHOLD) then
		stop(self)
		return
	end

	local axis
	if math.abs(dir.x) == 0 then
		axis = 'y'
	elseif math.abs(dir.y) == 0 then
		axis = 'x'
	else
		-- randomly select one of two directions
		axis = ({'x', 'y'})[math.random(1, 2)]
	end

	local shift = vmath.vector3()
	shift[axis] = math.max(-self.distance_per_step, math.min(dir[axis], self.distance_per_step))
	
	self.dir = shift
	animate_character(self)
	
	local duration = vmath.length(shift) / self.speed
	self.attempts = self.attempts + 1
	go.animate(
		'.',
		'position',
		go.PLAYBACK_ONCE_FORWARD,
		pos + shift,
		go.EASING_OUTBACK,
		duration,
		0,
		function(self)
			self.attempts = 0
			goto_target(self)
		end
	)
end

local function retry(self)
	if not self.target then
		stop(self)
		return
	end

	local pos = go.get_position()
	local shift = vmath.vector3()

	-- if self.attempts == 1 then
		-- first time just roll back a little
		shift = self.dir * -1/2
	-- elseif self.attempts == 2 then
	-- 	shift
	-- end

	go.animate(
		'.',
		'position',
		go.PLAYBACK_ONCE_FORWARD,
		pos + shift,
		go.EASING_OUTBACK,
		1,
		0,
		goto_target
	)
end

local function process_collision(self, message, sender)
	-- if message.group == hash("beacon") then
	-- end

	if message.group == hash('wall') or message.group == hash('hero') then
		-- Get the info needed to move out of collision. We might
		-- get several contact points back and have to calculate
		-- how to move out of all of them by accumulating a
		-- correction vector for this frame:
		if message.distance > 0 then
			-- First, project the accumulated correction onto
			-- the penetration vector
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
				-- Only care for projections that does not overshoot.
				local comp = (message.distance - message.distance * proj) * message.normal
				-- Apply compensation
				go.set_position(go.get_position() + comp)
				-- Accumulate correction done
				self.correction = self.correction + comp

				-- TODO: provide feedback when robot hits obstacle
				print('uh oh, robot vs. obstacle')

				-- Also, retry or stop
				if message.group == hash('wall') and self.attempts < self.max_attempts then
					go.cancel_animations('.', 'position')
					timer.delay(
						0,
						false,
						retry
					)
				else
					stop(self)
				end
			end
		end
	end
end

local function process_beacon(self, opts)
	stop(self)
	self.target = opts and opts.position or go.get_position('beacon')
	goto_target(self)
end

function init(self)
	reset(self)

	if self.should_walk_on_start then
		process_beacon(self)
	end
end

function update(self, dt)
	local pos = go.get_position()
	log.text(self.target and ('go to target' .. self.target) or 'idle', pos.x, pos.y + 12)
end

function on_message(self, message_id, message, sender)
	if message_id == hash('contact_point_response') then
		process_collision(self, message, sender)
	elseif message_id == hash('beacon') then
		process_beacon(self, message)
	end
end
